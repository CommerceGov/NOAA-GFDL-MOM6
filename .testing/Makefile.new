DEPS = deps
SHELL = bash
MPIRUN ?= mpirun # srun in Slurm, aprun in Cray-land, etc.

# GFDL build toolchain
MKMF_URL ?= https://github.com/NOAA-GFDL/mkmf.git
MKMF_COMMIT ?= master

LIST_PATHS = $(abspath $(DEPS)/mkmf/bin/list_paths)
MKMF = $(abspath $(DEPS)/mkmf/bin/mkmf)

# FMS framework
FMS_URL ?= https://github.com/NOAA-GFDL/FMS.git
FMS_COMMIT ?= f2e2c86f6c0eb6d389a20509a8a60fa22924e16b
FMS := $(DEPS)/fms

# Function to get list of files
# TODO: .h and .c files
#FMS_FILES = $(sort $(shell find $(FMS)/src -name '*.F90'))
#MOM_FILES = $(sort $(shell find src config_src/solo_driver -name '*.F90'))

# Build settings
MKMF_CPP = "-Duse_libMPI -Duse_netCDF -DSPMD"

# Environment
# TODO: This info ought to be determined by CMake, automake, etc.
MKMF_TEMPLATE ?= "linux-ubuntu-xenial-gnu.mk"
#MKMF_TEMPLATE ?= "ncrc-gnu.mk"
#MKMF_TEMPLATE ?= "ncrc-intel.mk"

# Reference codebase
MOM_TARGET_URL ?= https://github.com/NOAA-GFDL/MOM6.git
MOM_TARGET_REMOTE ?= target
MOM_TARGET_BRANCH ?= $(MOM_TARGET_REMOTE)/dev/gfdl

# Grid types
GRIDS = symmetric asymmetric

# Executables
# TODO: REPRO, coverage, ??
BUILDS = target $(GRIDS)

# Test experiments
CONFIGS ?= benchmark unit_tests
# regressions is currently broken (deliberately)
#TESTS = regressions grids nans
TESTS ?= grids nans


#-------------------
# Executable

.PHONY: all
all: $(foreach b,$(BUILDS),build/$(b)/MOM6)

# Executable
# TODO: Combine these, make checkout and MAKEFLAGS as inputs

build/target/MOM6: build/target/Makefile $(FMS)/lib/libfms.a
	git checkout $(MOM_TARGET_BRANCH)
	make -C $(@D) NETCDF=3 DEBUG=1 $(@F)
	git checkout @{-1}

build/symmetric/MOM6: build/symmetric/Makefile $(FMS)/lib/libfms.a
	make -C $(@D) NETCDF=3 DEBUG=1 COVERAGE=1 $(@F)

build/asymmetric/MOM6: build/asymmetric/Makefile $(FMS)/lib/libfms.a
	make -C $(@D) NETCDF=3 DEBUG=1 $(@F)

# Makefile

build/target/Makefile: BRANCH=$(MOM_TARGET_BRANCH)
build/%/Makefile: build/%/path_names
	if [ $(BRANCH) ]; then git checkout $(BRANCH); fi
	cp .testing/$(MKMF_TEMPLATE) $(@D)
	cd $(@D) && $(MKMF) \
		-t $(MKMF_TEMPLATE) \
		-o '-I ../../$(FMS)/build' \
		-p MOM6 \
		-l '../../$(FMS)/lib/libfms.a' \
		-c $(MKMF_CPP) \
		path_names
	if [ $(BRANCH) ]; then git checkout @{-1}; fi

# path_names

build/symmetric/path_names: $(LIST_PATHS)
	mkdir -p $(@D)
	cd $(@D) && $(LIST_PATHS) -l \
		../../src \
		../../config_src/solo_driver \
		../../config_src/dynamic_symmetric

build/asymmetric/path_names: $(LIST_PATHS)
	mkdir -p $(@D)
	cd $(@D) && $(LIST_PATHS) -l \
		../../src \
		../../config_src/solo_driver \
		../../config_src/dynamic

build/target/path_names: $(LIST_PATHS) .git/refs/remotes/$(MOM_TARGET_BRANCH)
	git checkout $(MOM_TARGET_BRANCH)
	mkdir -p $(@D)
	cd $(@D) && $(LIST_PATHS) -l \
		../../src \
		../../config_src/solo_driver \
		../../config_src/dynamic_symmetric
	git checkout @{-1}

# Target remote configuration

# XXX: ls-remote is probably redundant here; no file means ls-remote is nonzero!
# 	   Maybe move this into path_names rule?
.git/refs/remotes/$(MOM_TARGET_BRANCH):
	git ls-remote $(MOM_TARGET_REMOTE) \
		|| git remote add $(MOM_TARGET_REMOTE) $(MOM_TARGET_URL)
	git fetch --no-recurse-submodules $(MOM_TARGET_REMOTE)


#----
# FMS build

$(FMS)/lib/libfms.a: $(FMS)/build/Makefile
	mkdir -p $(FMS)/lib
	cd $(FMS)/build && make NETCDF=3 DEBUG=1 ../lib/libfms.a

$(FMS)/build/Makefile: $(FMS)/build/path_names
	cp .testing/$(MKMF_TEMPLATE) $(@D)
	cd $(@D) && $(MKMF) \
		-t $(MKMF_TEMPLATE) \
		-p ../lib/libfms.a \
		-c $(MKMF_CPP) \
		path_names

$(FMS)/build/path_names: $(FMS)/src $(FMS_FILES) $(LIST_PATHS)
	mkdir -p $(@D)
	cd $(@D) && $(LIST_PATHS) -l ../src

$(FMS)/src:
	git clone $(FMS_URL) $@
	cd $@; git checkout $(FMS_COMMIT)


#----
# Build Toolchain

$(LIST_PATHS) $(MKMF):
	git clone $(MKMF_URL) $(DEPS)/mkmf
	cd $(DEPS)/mkmf; git checkout $(MKMF_COMMIT)


#----
# Testing

# Keep results (not sure if I want this on all the time...)
.PRECIOUS: $(foreach c,$(CONFIGS),$(foreach t,$(BUILDS) grid nan dim.z dim.t,.testing/$(c)/ocean.stats.$(t)))

.PHONY: test
test: $(foreach t,$(TESTS),test.$(t))

.PHONY: $(foreach t,$(TESTS),test.$(t))
test.regressions: $(foreach c,$(CONFIGS),$(c).regression)
test.grids: $(foreach c,$(CONFIGS),$(c).grid)
test.nans: $(foreach c,$(CONFIGS),$(c).nan)

%.regression: $(foreach b,target symmetric,.testing/%/ocean.stats.$(b))
	cmp $^

%.grid: $(foreach g,$(GRIDS),.testing/%/ocean.stats.$(g))
	cmp $^

%.nan: $(foreach b,symmetric nan,.testing/%/ocean.stats.$(b))
	cmp $^

%.dim.z: $(foreach b,symmetric dim.z,.testing/%/ocean.stats.$(b))
	cmp $^

%.dim.t: $(foreach b,symmetric dim.t,.testing/%/ocean.stats.$(b))
	cmp $^

%.dim.l: $(foreach b,symmetric dim.l,.testing/%/ocean.stats.$(b))
	cmp $^

# symmetric is the "canonical" run for which we test and report code coverage
.testing/%/ocean.stats.symmetric: EXEC=build/symmetric/MOM6
.testing/%/ocean.stats.symmetric: CODECOV=1

.testing/%/ocean.stats.target: EXEC=build/target/MOM6

.testing/%/ocean.stats.asymmetric: EXEC=build/asymmetric/MOM6

.testing/%/ocean.stats.dim.z: EXEC=build/symmetric/MOM6
.testing/%/ocean.stats.dim.z: OVERRIDE="Z_RESCALE_POWER=9"

.testing/%/ocean.stats.dim.t: EXEC=build/symmetric/MOM6
.testing/%/ocean.stats.dim.t: OVERRIDE="T_RESCALE_POWER=9"

.testing/%/ocean.stats.dim.l: EXEC=build/symmetric/MOM6
.testing/%/ocean.stats.dim.l: OVERRIDE="L_RESCALE_POWER=9"

.testing/%/ocean.stats.nan: EXEC=build/symmetric/MOM6
.testing/%/ocean.stats.nan: MOM_ENV=MALLOC_PERTURB_=256

# TODO: Need to get my variable names straight...
STATS=target symmetric asymmetric dim.z dim.t nan

$(foreach t,$(STATS),.testing/%/ocean.stats.$(t)):
	if [ $(CODECOV) ]; then find build -name *.gcda -exec rm -f '{}' \; ; fi
	mkdir -p $(@D)/RESTART
	if [ $(OVERRIDE) ]; then echo $(OVERRIDE) > $(@D)/MOM_override; fi
	cd $(@D) && $(MOM_ENV) $(MPIRUN) -n 1 ../../$(EXEC)
	cp $(@D)/ocean.stats $@
	if [ $(CODECOV) ]; then bash <(curl -s https://codecov.io/bash) -n $@; fi
	if [ $(OVERRIDE) ]; then > $(@D)/MOM_override; fi


#----
.PHONY: clean
clean:
	rm -rf build
